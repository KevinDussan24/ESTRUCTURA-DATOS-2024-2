# -*- coding: utf-8 -*-
"""CODIGO BST CON TIEMPO Y RECORRIDO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sg5LHqtFKbZCZ1N1oTqwliODUIa-tHEU
"""

import java.util.ArrayList;
import java.util.List;

// Clase para el nodo del árbol
class Node {
    int key;
    Node left, right;

    public Node(int item) {
        key = item;
        left = right = null;
    }
}

// Clase para el Árbol Binario de Búsqueda (BST)
class BST {
    Node root;

    public BST() {
        root = null;
    }

    // Método para insertar un nuevo nodo
    void insert(int key) {
        measureTime("inserción", () -> {
            if (!find(key)) { // Evitar duplicados
                root = insertRec(root, key);
            } else {
                System.out.println("El valor " + key + " ya existe en el árbol.");
            }
        });
    }

    Node insertRec(Node root, int key) {
        if (root == null) {
            return new Node(key);
        }
        if (key < root.key) {
            root.left = insertRec(root.left, key);
        } else if (key > root.key) {
            root.right = insertRec(root.right, key);
        }
        return root;
    }

    // Método para eliminar un nodo
    void delete(int key) {
        measureTime("eliminación", () -> {
            if (find(key)) {
                root = deleteRec(root, key);
            } else {
                System.out.println("El valor " + key + " no existe en el árbol.");
            }
        });
    }

    Node deleteRec(Node root, int key) {
        if (root == null) return root;
        if (key < root.key) {
            root.left = deleteRec(root.left, key);
        } else if (key > root.key) {
            root.right = deleteRec(root.right, key);
        } else {
            if (root.left == null) return root.right;
            else if (root.right == null) return root.left;
            root.key = minValue(root.right);
            root.right = deleteRec(root.right, root.key);
        }
        return root;
    }

    int minValue(Node root) {
        while (root.left != null) {
            root = root.left;
        }
        return root.key;
    }

    // Método para recorrer el árbol en orden (in-order)
    List<Integer> inorder() {
        List<Integer> result = new ArrayList<>();
        measureTime("recorrido in-order", () -> inorderRec(root, result));
        return result;
    }

    void inorderRec(Node root, List<Integer> result) {
        if (root != null) {
            inorderRec(root.left, result);
            result.add(root.key);
            inorderRec(root.right, result);
        }
    }

    // Método para recorrer el árbol en pre-order
    List<Integer> preorder() {
        List<Integer> result = new ArrayList<>();
        measureTime("recorrido pre-order", () -> preorderRec(root, result));
        return result;
    }

    void preorderRec(Node root, List<Integer> result) {
        if (root != null) {
            result.add(root.key);
            preorderRec(root.left, result);
            preorderRec(root.right, result);
        }
    }

    // Método para recorrer el árbol en post-order
    List<Integer> postorder() {
        List<Integer> result = new ArrayList<>();
        measureTime("recorrido post-order", () -> postorderRec(root, result));
        return result;
    }

    void postorderRec(Node root, List<Integer> result) {
        if (root != null) {
            postorderRec(root.left, result);
            postorderRec(root.right, result);
            result.add(root.key);
        }
    }

    // Método para calcular el tamaño del árbol
    int size() {
        int[] result = new int[1];
        measureTime("cálculo del tamaño", () -> result[0] = sizeRec(root));
        return result[0];
    }

    int sizeRec(Node root) {
        return (root == null) ? 0 : 1 + sizeRec(root.left) + sizeRec(root.right);
    }

    // Método para calcular la altura del árbol
    int height() {
        int[] result = new int[1];
        measureTime("cálculo de la altura", () -> result[0] = heightRec(root));
        return result[0];
    }

    int heightRec(Node root) {
        return (root == null) ? 0 : 1 + Math.max(heightRec(root.left), heightRec(root.right));
    }

    // Método para buscar un valor en el árbol
    boolean find(int key) {
        boolean[] result = new boolean[1];
        measureTime("búsqueda", () -> result[0] = findRec(root, key));
        return result[0];
    }

    boolean findRec(Node root, int key) {
        if (root == null) return false;
        if (root.key == key) return true;
        return key < root.key ? findRec(root.left, key) : findRec(root.right, key);
    }

    // Método para medir el tiempo de ejecución
    void measureTime(String operationName, Runnable operation) {
        long startTime = System.nanoTime();
        operation.run();
        long endTime = System.nanoTime();
        System.out.println("Tiempo de " + operationName + ": " + (endTime - startTime) + " ns");
    }

    // Método principal para probar el BST
    public static void main(String[] args) {
        BST tree = new BST();

        // Insertar valores
        System.out.println("Insertando valores...");
        tree.insert(50);
        tree.insert(30);
        tree.insert(20);
        tree.insert(40);
        tree.insert(70);
        tree.insert(60);
        tree.insert(80);

        // Recorridos
        System.out.println("Recorrido in-order: " + tree.inorder());
        System.out.println("Recorrido pre-order: " + tree.preorder());
        System.out.println("Recorrido post-order: " + tree.postorder());

        // Tamaño y altura
        System.out.println("Tamaño del árbol: " + tree.size());
        System.out.println("Altura del árbol: " + tree.height());

        // Buscar valores
        System.out.println("¿Existe el nodo 40? " + tree.find(40));
        System.out.println("¿Existe el nodo 100? " + tree.find(100));

        // Eliminar nodos
        System.out.println("\nEliminando 20:");
        tree.delete(20);
        System.out.println("Recorrido in-order: " + tree.inorder());

        System.out.println("\nEliminando 30:");
        tree.delete(30);
        System.out.println("Recorrido in-order: " + tree.inorder());

        System.out.println("\nEliminando 50:");
        tree.delete(50);
        System.out.println("Recorrido in-order: " + tree.inorder());

        // Verificar tamaño y altura después de eliminar
        System.out.println("Tamaño del árbol: " + tree.size());
        System.out.println("Altura del árbol: " + tree.height());
    }
}

"""OTRO POSIBLE, SINMEASURE"""

// Clase para el nodo del árbol
class Node {
    int key;
    Node left, right;

    public Node(int item) {
        key = item;
        left = right = null;
    }
}

// Clase para el Árbol Binario de Búsqueda (BST)
class BST {
    Node root;

    public BST() {
        root = null;
    }

    // Método para insertar un nuevo nodo
    void insert(int key) {
        long startTime = System.nanoTime();
        if (!find(key)) { // Evitar duplicados
            root = insertRec(root, key);
        } else {
            System.out.println("El valor " + key + " ya existe en el árbol.");
        }
        long endTime = System.nanoTime();
        System.out.println("Tiempo de inserción: " + (endTime - startTime) + " ns");
    }

    Node insertRec(Node root, int key) {
        if (root == null) {
            return new Node(key);
        }
        if (key < root.key) {
            root.left = insertRec(root.left, key);
        } else if (key > root.key) {
            root.right = insertRec(root.right, key);
        }
        return root;
    }

    // Método para eliminar un nodo
    void delete(int key) {
        long startTime = System.nanoTime();
        if (find(key)) {
            root = deleteRec(root, key);
        } else {
            System.out.println("El valor " + key + " no existe en el árbol.");
        }
        long endTime = System.nanoTime();
        System.out.println("Tiempo de eliminación: " + (endTime - startTime) + " ns");
    }

    Node deleteRec(Node root, int key) {
        if (root == null) return root;
        if (key < root.key) {
            root.left = deleteRec(root.left, key);
        } else if (key > root.key) {
            root.right = deleteRec(root.right, key);
        } else {
            if (root.left == null) return root.right;
            else if (root.right == null) return root.left;
            root.key = minValue(root.right);
            root.right = deleteRec(root.right, root.key);
        }
        return root;
    }

    int minValue(Node root) {
        while (root.left != null) {
            root = root.left;
        }
        return root.key;
    }

    // Método para recorrer el árbol en orden (in-order)
    void inorder() {
        long startTime = System.nanoTime();
        System.out.print("Recorrido in-order: ");
        inorderRec(root);
        System.out.println();
        long endTime = System.nanoTime();
        System.out.println("Tiempo de recorrido in-order: " + (endTime - startTime) + " ns");
    }

    void inorderRec(Node root) {
        if (root != null) {
            inorderRec(root.left);
            System.out.print(root.key + " ");
            inorderRec(root.right);
        }
    }

    // Método para recorrer el árbol en pre-order
    void preorder() {
        long startTime = System.nanoTime();
        System.out.print("Recorrido pre-order: ");
        preorderRec(root);
        System.out.println();
        long endTime = System.nanoTime();
        System.out.println("Tiempo de recorrido pre-order: " + (endTime - startTime) + " ns");
    }

    void preorderRec(Node root) {
        if (root != null) {
            System.out.print(root.key + " ");
            preorderRec(root.left);
            preorderRec(root.right);
        }
    }

    // Método para recorrer el árbol en post-order
    void postorder() {
        long startTime = System.nanoTime();
        System.out.print("Recorrido post-order: ");
        postorderRec(root);
        System.out.println();
        long endTime = System.nanoTime();
        System.out.println("Tiempo de recorrido post-order: " + (endTime - startTime) + " ns");
    }

    void postorderRec(Node root) {
        if (root != null) {
            postorderRec(root.left);
            postorderRec(root.right);
            System.out.print(root.key + " ");
        }
    }

    // Método para calcular el tamaño del árbol
    int size() {
        long startTime = System.nanoTime();
        int result = sizeRec(root);
        long endTime = System.nanoTime();
        System.out.println("Tiempo de cálculo del tamaño: " + (endTime - startTime) + " ns");
        return result;
    }

    int sizeRec(Node root) {
        return (root == null) ? 0 : 1 + sizeRec(root.left) + sizeRec(root.right);
    }

    // Método para calcular la altura del árbol
    int height() {
        long startTime = System.nanoTime();
        int result = heightRec(root);
        long endTime = System.nanoTime();
        System.out.println("Tiempo de cálculo de la altura: " + (endTime - startTime) + " ns");
        return result;
    }

    int heightRec(Node root) {
        return (root == null) ? 0 : 1 + Math.max(heightRec(root.left), heightRec(root.right));
    }

    // Método para buscar un valor en el árbol
    boolean find(int key) {
        long startTime = System.nanoTime();
        boolean result = findRec(root, key);
        long endTime = System.nanoTime();
        System.out.println("Tiempo de búsqueda: " + (endTime - startTime) + " ns");
        return result;
    }

    boolean findRec(Node root, int key) {
        if (root == null) return false;
        if (root.key == key) return true;
        return key < root.key ? findRec(root.left, key) : findRec(root.right, key);
    }

    // Método principal para probar el BST
    public static void main(String[] args) {
        BST tree = new BST();

        // Insertar valores
        System.out.println("Insertando valores...");
        tree.insert(50);
        tree.insert(30);
        tree.insert(20);
        tree.insert(40);
        tree.insert(70);
        tree.insert(60);
        tree.insert(80);

        // Recorridos
        tree.inorder();
        tree.preorder();
        tree.postorder();

        // Tamaño y altura
        System.out.println("Tamaño del árbol: " + tree.size());
        System.out.println("Altura del árbol: " + tree.height());

        // Buscar valores
        System.out.println("¿Existe el nodo 40? " + tree.find(40));
        System.out.println("¿Existe el nodo 100? " + tree.find(100));

        // Eliminar nodos
        System.out.println("\nEliminando 20:");
        tree.delete(20);
        tree.inorder();

        System.out.println("\nEliminando 30:");
        tree.delete(30);
        tree.inorder();

        System.out.println("\nEliminando 50:");
        tree.delete(50);
        tree.inorder();

        // Verificar tamaño y altura después de eliminar
        System.out.println("Tamaño del árbol: " + tree.size());
        System.out.println("Altura del árbol: " + tree.height());
    }
}